# Objective
# Dataset X_i in [-pi, +pi] x [-pi, +pi]
# Class Y_in {-1, +1} such that
# y_i(w_0 + w_1x_{i1} + w_2x_{i2} + w_3 cos(x_{i1}) + w_4 sin(x_{i1})) > 0
# w_0, w_1, w_2, w_3 and w_4 are randomly chosen parameters N(0,1)
# Find optimal parameters for w_0, w_1, w_2, w_3 and w_4 to maximize the margin generated by level set
# {(x_1, x_2) : w_0 + w_1x_{i1} + w_2x_{i2} + w_3 cos(x_{i1}) + w_4 sin(x_{i1}) = 0}

# Plot the decision boundary

library("quadprog")
set.seed(20)
# number of dimensions
d=2
#number of observations
N = 50;
w = rnorm(5)
X = matrix(0,nrow = N, ncol = d); 

y = rep(0,N);  
for (i in 1:N) { 
  X[i,] = 2*pi*runif(2) - pi
  
  c = cos(X[i,1])
  s = sin(X[i,1])

  y[i] = sign(w[1] + w[2] * X[i,1]+ w[3] * X[i,2] + w[4] * c + w[5]* s)  # choose data to be linearly separable
 
}
plot(X,pch = y+2,col=y+3,cex=1)   # observe data 


X = cbind(sin(X[,1]),cos(X[,1]),X)
feat =5

D = diag(feat); 
D[feat,feat] = .001;    # this is the kludge for b
d = rep(0,feat);
A = cbind(X*y,y);

b = rep(1,N);
result = solve.QP(D,d,t(A),b);  # painless QP result from package!!
what = result$solution[1:5]


x1 = (X[,3]); 
#  solve for x2 in 
#  what[1]*sin(x1) + what[2]*cos(x1) + what[3]*x1 + what[4]*x2 + what[5] = 0

x2  =  (-what[1]*sin(x1) - what[2]*cos(x1) - what[3]*x1 - what[5])/what[4]

lines(x1[order(x1)],x2[order(x1)],col='green')

